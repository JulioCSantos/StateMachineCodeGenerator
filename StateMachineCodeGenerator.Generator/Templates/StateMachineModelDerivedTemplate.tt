<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ import namespace="StateMachineMetadata.Model" #> 
<#@ import namespace="StateMachineMetadata.Extensions" #>
<#@ import namespace="StateMachineCodeGeneratorSystem.Templates" #>
// Created by t4 template '<#= this.GetType().Name #>'
<#@ include file="Parts/CopyrightHeader.t4" #>
<# var model = StateMachineMetadata.Main.ActiveModel; #>
using GenSysCommon.Interfaces;
using System;
using System.Collections.Generic;
using System.Threading;
using System.ComponentModel;
using Corning.GenSys.Logger;
using NorthStateSoftware.NorthStateFramework;
using System.Threading.Tasks;
using System.Linq;
using Corning.GenSys.Scanning;
using System.Runtime.CompilerServices;


namespace <#= Session["NameSpace"].ToString() #>
{
    // ReSharper disable once InconsistentNaming
    public partial class <#= Session["typeName"].ToString() #> : <#= Session["StateMachineModelBaseTypeName"].ToString() #>, IDisposable
    {

        #region properties

        #region EventIds
<#   foreach (var faultTriggerName in model.NSF.GetFaultTriggerNames())  { #>
<#   var faultName = faultTriggerName.Replace("Fault", "").ToValidCSharpName(); #>
        public override string <#= faultName #>FaultEventId { get { return nameof(EventBroker.<#= faultName #>FaultEventId); } } 
<# } #>
        #endregion EventIds

        #endregion properties

        #region Constructors

        #region Singleton        
        private static readonly object SingletonLock = new object();
        private static <#= Session["StateMachineModelDerivedTypeName"].ToString() #> mainModel;
        public static <#= Session["StateMachineModelDerivedTypeName"].ToString() #> GetSingleton()
        {
                if (mainModel != null) return mainModel;
                lock (SingletonLock)
                {
                    return mainModel ?? (mainModel = new <#= Session["StateMachineModelDerivedTypeName"].ToString() #>(<#= Session["StateMachineBaseTypeName"].ToString() #>.StateMachineName));
                }
        }
        #endregion Singleton

        private <#= Session["typeName"].ToString() #>(string strName)
        {
            base.StateMachine = new <#= Session["StateMachineDerivedTypeName"].ToString() #>(strName, this);
            base.RegisterFaultEventMethods();
            this.PropertyChanged += <#= Session["StateMachineModelDerivedTypeName"].ToString() #>_PropertyChanged;
        }
        #endregion Constructors

        #region methods
            private void <#= Session["StateMachineModelDerivedTypeName"].ToString() #>_PropertyChanged(object sender, PropertyChangedEventArgs e) {
            switch (e.PropertyName) {
                case nameof(IsInInitState):
                    break;
            }
        }        
        #endregion methods

        #region IDisposable
        // Flag: Has Dispose already been called?
        bool disposed = false;

        // Public implementation of Dispose pattern callable by consumers.
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        // Protected implementation of Dispose pattern.
        protected virtual void Dispose(bool disposing)
        {
            if (disposed) return;

            if (disposing)
            {
                if (StateMachine.TerminationStatus == NSFEventHandlerTerminationStatus.EventHandlerReady)
                    NSFEnvironment.terminate();
            }

            // Free any unmanaged objects here.

            disposed = true;
        }

        ~<#= Session["StateMachineModelDerivedTypeName"].ToString() #>() { Dispose(false); }
        #endregion IDisposable

    }
}