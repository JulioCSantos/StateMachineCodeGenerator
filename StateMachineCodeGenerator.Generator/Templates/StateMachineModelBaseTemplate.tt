<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ import namespace="StateMachineMetadata.Extensions" #> 
<#@ import namespace="StateMachineMetadata.Model" #> 
<#@ import namespace="StateMachineCodeGeneratorSystem.Templates" #>
// Created by t4 template '<#= this.GetType().Name #>'
<#@ include file="Parts/CopyrightHeader.t4" #>
<# var model = StateMachineMetadata.Main.ActiveModel; #>
using System;
using System.Collections.Generic;
using System.Threading;
using System.ComponentModel;
using Corning.GenSys.Logger;
using NorthStateSoftware.NorthStateFramework;
using System.Threading.Tasks;
using System.Linq;
using System.Runtime.CompilerServices;
using GenSysCommon;
using GenSysCommon.Interfaces;
using Corning.GenSys.MVVMCommon;

namespace <#= Session["NameSpace"].ToString() #>
{
    // ReSharper disable once InconsistentNaming
    public class <#= Session["typeName"].ToString() #> : INotifyPropertyChanged
    {
        private <#= Session["StateMachineDerivedTypeName"].ToString() #> stateMachine;
        public <#= Session["StateMachineDerivedTypeName"].ToString() #> StateMachine 
		{ 
			get { return stateMachine; }
			protected set {
				stateMachine = value;
                if (stateMachine != null)
                    this.StateMachine.StateChangesAtStateEvent += StateChangesAtState;
			}
		}
        private static readonly ILogger ms_iLogger = CLoggerFactory.CreateLog("<#= Session["typeName"].ToString() #>");

        #region Constructors
        protected internal <#= Session["typeName"].ToString() #>() { }
        #endregion Constructors

        #region ExceptionsToFaults
        public virtual void RegisterFaultEventMethods()
        {
<#   foreach (var faultTriggerName in model.NSF.GetFaultTriggerNames())  { #>
<#   var faultName = faultTriggerName.Replace("Fault", "").ToValidCSharpName(); #>
            //var <#= faultName #>Publisher = C<#= faultName #>.GetInstance();
            //EventBroker.Instance.RegisterEvent(<#= faultName #>Publisher, "<#= faultName #>FaultEvent", eventId:<#= faultName #>FaultEventId);
            EventBroker.Instance.RegisterEventMethods(<#= faultName #>FaultEventId, this, nameof(<#= faultName #>ExceptionTo<#= faultName #>Fault));

<# } #>
        }

<#   foreach (var faultTriggerName in model.NSF.GetFaultTriggerNames())  { #>
<#   var faultName = faultTriggerName.Replace("Fault", "").ToValidCSharpName(); #>
        public virtual string <#= faultName #>FaultEventId { get { return nameof(<#= faultName #>FaultEventId); } } 
        public virtual void <#= faultName #>ExceptionTo<#= faultName #>Fault(object sender, EventArgs args)
        {
            StateMachine.SendStateEvent(TriggerName.<#= faultName #>FaultEvent);
        }

<# } #>
        #endregion ExceptionsToFaults

        #region State indicators ("IsIn...")

<#  foreach (var state in model.States.OfType<State>().OrderBy(s => s.Name))  {  
        var fieldName = "isIn" + state.Name.Substring(0,1).ToUpper() + state.Name.Substring(1);
        var propName =  "IsIn" + state.Name.Substring(0,1).ToUpper() + state.Name.Substring(1);
#>
        #region <#= propName #>
        private bool <#= fieldName #>;
        public bool <#= propName #>
        {
            get { return <#= fieldName #>; }
            internal set { SetProperty(ref <#= fieldName #>, value); }
        }
        #endregion <#= propName #>

<#  } #>

        #endregion State indicators ("IsIn...")

        #region States Actions
        
<#  var previousActionNames = new HashSet<string>();
    foreach (var state in model.States.OfType<State>().OrderBy(s => s.Name))  {  
        if (state.EntryActions.Any()) {#>
<#          foreach (var sAction in state.EntryActions.Where(a => string.IsNullOrEmpty(a) == false)) { 
                if (previousActionNames.Add(sAction) == false) continue; //avoid duplicates #>
        /// <summary>
        /// <#= state.Name #>'s Action
        /// </summary>
        public virtual async Task <#= sAction#>() { await Task.CompletedTask; }

<#          }#>
<#      }#>
<#      if (state.ExitActions.Any()) {#>
<#          foreach (var sAction in state.ExitActions.Where(a => string.IsNullOrEmpty(a) == false)) { 
                if (previousActionNames.Add(sAction) == false) continue; //avoid duplicates #>
        /// <summary>
        /// <#= state.Name #>'s Action
        /// </summary>        
        public virtual async Task <#= sAction#>() { await Task.CompletedTask; }

<#          }#>
<#      }#>
<#  } #>

        #endregion States Actions

	    #region Transitions Actions
<#  var previousActions = new HashSet<string>();
    var previousTActs = new HashSet<string>();
    foreach (var group in model.NSF.GetGroupedTransitions())  {  
        foreach (var trans in group.GroupBy(g => g.Name).Select(g => g.First()).Where(t => string.IsNullOrEmpty(t.ActionName) == false)) { 
            if (previousActions.Add(trans.ActionName) == false) continue; //avoid duplicates
            var eTrans= trans as ExternalTransition;
            var iTrans= trans as InternalTransition;
            string triggerName = "'trigger is missing'"; 
            if (trans.Trigger != null) triggerName = trans.Trigger.Name; 
#>
<#          foreach (var tAct in model.NSF.Model.Transitions.Where(t => t.ActionName == trans.ActionName && t.Actions != null).SelectMany(t => t.Actions).Distinct() ) 
            {
                if (previousTActs.Add(tAct) == false) continue; //avoid duplicates
                if (StringExtensions.IsValidIdentifier(tAct) == false) { 
                    Ext.WriteTokensAtTabs(this,2, "// +++ Invalid Action name '" + tAct.ToString() + "' in " + triggerName);
                    continue; 
                }
#>
        /// <summary>
        /// <#= trans.Name #>:
<#              if (eTrans != null) Ext.WriteTokensAtTabs(this, 2,"/// This method is called when the '" +  eTrans.SourceState.Name + "' transitions to '" + eTrans.Target.Name + "'");
                else Ext.WriteTokensAtTabs(this, 2,"/// This method is called when transitioning from '" +  iTrans.SourceState.Name + "'"); #>
        /// triggered by '<#= triggerName #>' 
        /// </summary>
        /// <param name="oContext">Information about the states before and after the transition as well as the transition and trigger.</param>
        /// <returns>Nothing</returns>
        public virtual async Task <#= tAct #>(NSFStateMachineContext oContext)
        {
            await Task.CompletedTask;
        }
<#          } #>

<#        } 
    } #>
		#endregion Transitions Actions

	    #region Transitions Guards
<#  var previousGuards = new HashSet<string>();
    foreach (var group in model.NSF.GetGroupedTransitions())  {  
        foreach (var trans in group.GroupBy(g => g.Name).Select(g => g.First()).Where(t => string.IsNullOrEmpty(t.GuardName) == false)) { 
            if (previousGuards.Add(trans.GuardName) == false) continue; //avoid duplicates 
            if (trans.GuardName == null || trans.GuardName.ToUpper() == "NONE") continue; //skip "None" or "null" Guards
            if (trans.GuardName.ToUpper() == "ELSE") continue; //skip Guards named "Else"
            var simulationIndicatorName = trans.GuardName + "_InSimulationMode";
            var simulationValueName= trans.GuardName + "_SimulatedValue";
#>
        // ReSharper disable once InconsistentNaming
        private bool <#= trans.GuardName.ToCamelCase() #>;
        /// <summary>
        /// A Guard function returning the State of '<#= trans.GuardName #>'.
        /// Defined at Transition <#= trans.Name #>
        /// </summary>
        /// <returns>guard result</returns>
        // ReSharper disable once InconsistentNaming
        public virtual bool <#= trans.GuardName #>
        {
            get {
                    ms_iLogger.Log(ELogLevel.Info, "'<#= trans.GuardName #>' not initialized");
                    throw new NotImplementedException(); 
                }
                set { <#= trans.GuardName.ToCamelCase() #> = value; }
    }

<#        } 
    } #>
		#endregion Transitions Guards

        #region States changes handling
<# var AtStateMethods = new HashSet<string>();
    foreach (var trans in model.Transitions.Where(t => t.Trigger != null && t.Trigger.Name != null).OrderBy(t => t.SourceState.Name))  { 
        if (AtStateMethods.Add(trans.SourceState.Name) == false) continue; //avoid duplicates 
#>
        public virtual async Task At<#= trans.SourceState.Name.ToValidCSharpName() #>()
        {
            //StateMachine.SendStateEvent(TriggerName.<#= trans.Trigger.Name #>);
			await Task.CompletedTask;
        }

<# } #>

        #endregion States changed

        #region State changes handling
        public async void StateChangesAtState(object sender, StateChangesEventArgs eventArgs)
        {
            if (eventArgs.HandledStateName == null) return;
            EState eState;
            Enum.TryParse(eventArgs.HandledStateName, out eState);
            if (eState == EState.none) System.Diagnostics.Debugger.Break();

            switch (eState)
            {
<# var stateCases = new HashSet<string>();
    foreach (var trans in model.Transitions.Where(t => t.Trigger != null && t.Trigger.Name != null).OrderBy(t => t.SourceState.Name))  { 
        if (stateCases.Add(trans.SourceState.Name) == false) continue; //avoid duplicates 
#>

                case EState.<#= trans.SourceState.Name.ToValidCSharpName().Replace("State","") #>:
                    try { await At<#= trans.SourceState.Name.ToValidCSharpName() #>(); }
                    catch (Exception e)
                    {
                        ms_iLogger.LogException(ELogLevel.Error, e.Source, e);
                        StateMachine.SendStateEvent(TriggerName.UndefinedFaultEvent);
                    }
                    break;
<# } #>

            }
        } 
        #endregion State changes handling


		#region CancellationTokenSources

<#    foreach (var faultTriggerName in (new List<string>(){"MainFault"}).Union(model.NSF.GetFaultTriggerNames()))  { #>
<#   var propertyName = faultTriggerName.ToValidCSharpName() + "CancellationTokenSource"; #>
<#   var backingField = "_" + propertyName.Substring(0,1).ToLower() + propertyName.Substring(1); #>
        #region <#= propertyName #>
        private CancellationTokenSource <#= backingField #>;
        public CancellationTokenSource <#= propertyName #>
        {
            get { return <#= backingField #> ?? (<#= propertyName #> = new CancellationTokenSource()); }
            set 
            { 
                <#= backingField #>?.Dispose();
                SetProperty(ref <#= backingField #>, value); 
            }
        }
        #endregion <#= propertyName #>

<# } #>
		#endregion CancellationTokenSources


        #region INotifyPropertyChanged
        public event PropertyChangedEventHandler PropertyChanged;
        public void RaisePropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
        protected virtual bool SetProperty<T>(ref T prevValue, T value, [CallerMemberName] string propertyName = null)
        {
            if (Equals(prevValue, value)) return false;
            prevValue = value;
            this.RaisePropertyChanged(propertyName);
            return true;
        }
        #endregion INotifyPropertyChanged
    }
}