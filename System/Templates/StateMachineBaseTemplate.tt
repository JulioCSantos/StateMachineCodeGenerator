<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ import namespace="StateMachineMetadata.Model" #> 
<#@ import namespace="StateMachineMetadata.Extensions" #> 
// Created by t4 template '<#= this.GetType().Name #>'
<#@ include file="Parts/CopyrightHeader.t4" #>
<#@ include file="Parts/GensysQuickStartGuide.t4" #>
<# var model = StateMachineMetadata.Main.ActiveModel; #>
using System;
using System.Windows;
using System.Drawing;
using System.Collections.Generic;
using System.Threading;
using System.ComponentModel;
using Corning.GenSys.Logger;
using NorthStateSoftware.NorthStateFramework;
using System.Threading.Tasks;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using Corning.GenSys.Scanning;
using GenSysCommon;
using GenSysCommon.Interfaces;
using NSFEventName = System.String;

// ReSharper disable InconsistentNaming
namespace XYZPDQ.Model
{
    public partial class <#= Session["typeName"].ToString() #> : NSFStateMachine 
    {
        #region Fields and Properties
        internal static ILogger ms_iLogger = CLoggerFactory.CreateLog("C<#= model.ProjectName #>StateMachine");
        public const string StateMachineName = "<#= model.ProjectName#>";
        //private object m_objLock = new object();

        public Dictionary<NSFEventName, NSFEvent> Triggers { get; } = new Dictionary<NSFEventName, NSFEvent>();
        public string SystemState {get; private set;}
        public EState? CurrentState { get; private set; }
        public EState? PreviousState { get; private set; }
        public NSFStateMachineContext CurrentContext { get; private set; }
        public NSFStateMachineContext PreviousContext { get; private set; }

        //private bool m_bSimulationMode = false;

        #region OperatorPromptForStateDict
        private Dictionary<EState, (string OperatorPrompt, bool HighlightPrompt)> m_odictOperatorPromptForState;
        public Dictionary<EState, (string OperatorPrompt, bool HighlightPrompt)> OperatorPromptForStateDict
            { get { return m_odictOperatorPromptForState ?? (m_odictOperatorPromptForState = new Dictionary<EState, (string OperatorPrompt, bool HighlightPrompt)>() ); } }
        #endregion OperatorPromptForStateDict
       
        public string LastOperatorPrompt { get; private set; }
		public virtual string UndefinedFaultEvent { get; } = TriggerName.UndefinedFaultEvent;
        public <#= Session["StateMachineModelDerivedTypeName"].ToString() #> MainModel {get; }
        
        private StateChangesEventArgs _stateChangesEventArgs;
        public StateChangesEventArgs StateChangesEventArgs
        {
            get { return _stateChangesEventArgs ?? (_stateChangesEventArgs = new StateChangesEventArgs( /*CurrentContext, MetaData*/ )); }
            //set { _stateChangesEventArgs = value; }
        }
        #endregion Fields and Properties

        #region Constructors
        protected internal <#= Session["typeName"].ToString() #>(string strName, <#= Session["StateMachineModelDerivedTypeName"].ToString() #> mainModel) 
			: base(strName, new NSFEventThread(strName)) 
        { 
            MainModel = mainModel; 
            CreateStateMachine();
            //MetaData = GetMetadata();
        }

        //private StateMachineMetaData _metaData;
        //public StateMachineMetaData MetaData
        //{
            //get { return _metaData ?? (_metaData = new StateMachineMetaData()); }
            //set { _metaData = value; }
        //}


        private StateMachineMetaData GetMetadata()
        {
            var metaData = new StateMachineMetaData();
            var triggersInfo = this.GetType().GetFields(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public)
                .Where(pi => pi.FieldType == typeof(NSFEvent)).ToList();

            foreach (var triggerInfo in triggersInfo)
            {
                var nEvent = triggerInfo.GetValue(this) as NSFEvent;
                var trigger = new TriggerEvent(nEvent);
                metaData.TriggerEvents.Add(trigger.Name, trigger);
            }

            var statesInfo = this.GetType().GetFields(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public)
                .Where(pi => pi.FieldType == typeof(NSFInitialState) || pi.FieldType == typeof(NSFCompositeState) || pi.FieldType == typeof(NSFChoiceState)).ToList();


            foreach (var stateInfo in statesInfo)
            {
                var nState = stateInfo.GetValue(this) as NSFState;
                StateBase state = null;
                if (stateInfo.FieldType == typeof(NSFCompositeState)) state = new CompositeState(nState as NSFCompositeState);
                if (stateInfo.FieldType == typeof(NSFInitialState)) state = new InitialState(nState as NSFInitialState);
                if (stateInfo.FieldType == typeof(NSFChoiceState)) state = new ChoiceState(nState as NSFChoiceState);
                if (state != null) metaData.States.Add(state.Name, state);
                else System.Diagnostics.Debugger.Break();
            }

            var transitionsInfo = this.GetType().GetProperties(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public)
                .Where(pi => pi.PropertyType == typeof(NSFExternalTransition) || pi.PropertyType == typeof(NSFInternalTransition)).ToList();

            foreach (var transInfo in transitionsInfo)
            {
                var nTrans = transInfo.GetValue(this) as NSFTransition;
                TransitionBase trans = null;
                if (transInfo.PropertyType == typeof(NSFExternalTransition))
                {
                    trans = new ExternalTransition(nTrans as NSFExternalTransition);
                    var extTrans = trans as ExternalTransition;
                    extTrans.SourceState = metaData.States[nTrans.Source.Name] as CompositeState;
                    extTrans.TargetState = metaData.States[nTrans.Target.Name] as CompositeState;
                    //if (extTrans.SourceState == null || extTrans.TargetState == null) System.Diagnostics.Debugger.Break();
                }

                if (transInfo.PropertyType == typeof(NSFInternalTransition))
                {
                    trans = new InternalTransition(nTrans as NSFInternalTransition);
                    var intTrans = trans as InternalTransition;
                    if (intTrans.State != null)
                        intTrans.State = metaData.States[intTrans.State.Name] as CompositeState;
                    //else System.Diagnostics.Debugger.Break();
                }

                if (trans == null) System.Diagnostics.Debugger.Break();
                else {
                    if (nTrans.Triggers.Any())
                        trans.TriggerEvent = metaData.TriggerEvents[nTrans.Triggers.First().Name];
                    //else System.Diagnostics.Debugger.Break();
                    metaData.Transitions.Add(trans.Name, trans);
                }
            }

            return metaData;
        }
        #endregion Constructors

		#region Events
<# foreach (var triggerName in model.NSF.GetTriggerNames())  { #>
		public NSFEvent o<#= triggerName.ToValidCSharpName() #>;
<# } #>
		#endregion Events


		#region States
<#  foreach (var group in model.NSF.GetNamedStatesGroupedByOwner())  {  #>
<#      if (group.Key == null) Ext.WriteTokensAtTabs(this, 2, "// root state definition"); 
        else Ext.WriteTokensAtTabs(this, 2, "// " + group.Key.Name + "'s substate definitions");  #>
<#      foreach (var state in group) {
            Ext.WriteTokensAtTabs(this, 2,"public " + state.ToNSFType(), 9,"o" + state.Name + ";");
        }
    } #>
        
        #endregion States

        #region StateLocations

        private Dictionary<string, Rectangle> dictStateLocation = new Dictionary<string, Rectangle>{

<#      foreach (var group in model.NSF.GetNamedStatesGroupedByOwner())  
        {  
            if (group.Key == null) 
                Ext.WriteTokensAtTabs(this, 2, "// root state definition"); 
            else 
                Ext.WriteTokensAtTabs(this, 2, " // " + group.Key.Name + "'s substates");
            foreach (var state in group) 
            {
                Ext.WriteTokensAtTabs(this, 2," {\"" + state.Name + "\", new Rectangle(" + state.Coord.Left + "," + state.Coord.Top.ToString() + "," + 
                            (state.Coord.Right - state.Coord.Left).ToString() + "," + (state.Coord.Bottom - state.Coord.Top).ToString() + ")}, " );
            }
        }  #>
        {"LastState", new Rectangle(1, 2, 3, 4)}};

        public Dictionary<string, Rectangle> DictStateLocation
        {
            get => dictStateLocation;
            set => dictStateLocation = value;
        }
		#endregion StateLocations

		#region Transitions
<#  foreach (var group in model.NSF.GetGroupedTransitions())  {  #>
<#      if (group.Key == null) Ext.WriteTokensAtTabs(this, 2, "// root Transitions' definitions"); 
        else Ext.WriteTokensAtTabs(this, 2, "// From " + group.Key.Name + " Transitions' definitions");  #>
<#      foreach (var transition in group.GroupBy(g => g.Name).Select(g => g.First())) { #>
        public <#= transition.ToNSFType() #> <#= transition.Name #> {get; private set;}
<#      } #>

<#  } #>
		#endregion Transitions

        private void CreateStateMachine()
        {

            BeforeCreateStateMachine();

		    #region Events  instantiations
<# foreach (var triggerName in model.NSF.GetTriggerNames())  { #>
		    o<#= triggerName #> = new NSFEvent(nameof(o<#= triggerName #>), this, this);
<# } #>

<# foreach (var triggerName in model.NSF.GetTriggerNames())  { #>
            Triggers.Add(TriggerName.<#= triggerName.ToValidCSharpName() #>, o<#= triggerName.ToValidCSharpName() #>);
<# } #>
		    #endregion Events

		    #region States instantiations
<#  foreach (var group in model.NSF.GetNamedStatesGroupedByOwner())  {  #>
<#      if (group.Key == null) Ext.WriteTokensAtTabs(this, 3, "// root state instantiation"); 
        else Ext.WriteTokensAtTabs(this, 3, "// " + group.Key.Name + "'s substate instantiation");  #>
<#      foreach (var state in group) {
            var name = state.Name;
            var oName = "o" + state.Name;
            var ownrName = state.Owner == null ? "this" : "o" + state.Owner.Name ;
            if (state is StateMachineMetadata.Model.State) { 
                string enterAction;
                if (state.EntryActions.Any()) enterAction = "(c) => " + name + "EnteredAsync(c, " + oName + ")";
                else enterAction = "(c) => RaiseStateEnterEvent(c, " + oName + ")";
                string exitAction;
                if (state.ExitActions.Any()) exitAction = "(c) => " + name + "ExitedAsync(c, " + oName + ")";
                else exitAction = "(c) => RaiseStateExitEvent(c, " + oName + ")";
                Ext.WriteTokensAtTabs(this, 3, oName + " = new NSFCompositeState(nameof(" + oName + "), " + ownrName + 
                    ", " + enterAction + ", " + exitAction + ");");
            }
            if (state is StateMachineMetadata.Model.ChoiceState) 
                Ext.WriteTokensAtTabs(this, 3, oName + " = new NSFChoiceState(nameof(" + oName + "), " + ownrName + ");");
            if (state is StateMachineMetadata.Model.InitialState) 
                Ext.WriteTokensAtTabs(this, 3, oName + " = new NSFInitialState(nameof(" + oName + "), " + ownrName + ");");

         } #>

<#  } #>
		    #endregion States  instantiations

	        #region Transitions instantiations
<#  foreach (var group in model.NSF.GetGroupedTransitions())  {  
      if (group.Key == null) Ext.WriteTokensAtTabs(this, 3, "// root Transitions' definitions"); 
      else Ext.WriteTokensAtTabs(this, 3, "// From " + group.Key.Name + " Transitions' definitions");  
      foreach (var trans in group.GroupBy(g => g.Name).Select(g => g.First())) { #>
<#
        var statement = trans.Name + " = new " + trans.ToNSFType() + "(nameof(" + trans.Name + ")"; 
        var actionName = trans.ActionName == null ? "null" : "async (c) => await " + trans.ActionName.ToValidCSharpName() + "(c)";
        var guardName = trans.GuardName.ToUpper() == "NONE" ? "null" : trans.GuardName;

        var eTrans = trans as ExternalTransition;
        if (eTrans != null)  {
            var triggerName = (eTrans.Trigger == null || string.IsNullOrEmpty(eTrans.Trigger.Name) ? "null" : "o" + eTrans.Trigger.Name).ToValidCSharpName();
            Ext.WriteTokensAtTabs(this, 3, statement + ", o" + eTrans.Source.Name + ", o" + eTrans.Target.Name 
                + ", " + triggerName + ", " + guardName + ", " + actionName + ");"); 
        }
        var iTrans = trans as InternalTransition;
        if (iTrans != null) { 
            var triggerName = (iTrans.Trigger == null || string.IsNullOrEmpty(iTrans.Trigger.Name) ? "null" : "o" + iTrans.Trigger.Name).ToValidCSharpName();
            Ext.WriteTokensAtTabs(this, 3, statement + ", o" + iTrans.OwnerState.Name
                + ", " + triggerName + ", " + guardName + ", " + actionName + ");"); 
        } 
#>
<#    } #>

<#  } #>
		    #endregion Transitions instantiations

            AfterCreateStateMachine();

        }

        public virtual void BeforeCreateStateMachine() { }
        public virtual void AfterCreateStateMachine() { }

        #region C# Events
        public delegate void StateChangesEventHandler(object sender, StateChangesEventArgs stateChangesEventArgs);
        public event StateChangesEventHandler StateChangesEvent;
        public event StateChangesEventHandler StateChangesAtStateEvent;
        //public delegate Task StateChangedEventHandler(PropertyChangedEventArgs e);
        //public delegate Task StateChangingEventHandler(PropertyChangedEventArgs e);
        //public event StateChangingEventHandler StateEnteredAsync;
        //public event StateChangedEventHandler StateExitedAsync;
        #endregion C# Events

        #region State Machine Methods

        #region States Actions

<#  foreach (var state in model.States.OfType<State>().OrderBy(s => s.Name))  {  #>
<#        if (state.EntryActions.Any()) {#>
        public virtual async Task <#= state.Name.ToValidCSharpName() #>EnteredAsync(NSFStateMachineContext oContext, NSFState state)
        {
            try {
                this.RaiseStateEnterEvent(oContext, state);
<#            foreach (var sAction in state.EntryActions.Where(a => string.IsNullOrEmpty(a) == false)) { #>
                await MainModel.<#= sAction#>().ConfigureAwait(continueOnCapturedContext:false);
<#            }#>
            }
            catch (Exception e)
            {
                ms_iLogger.LogException(ELogLevel.Error, e.Source, e);
                this.SendStateEvent(UndefinedFaultEvent);
            }
        }
<#        }#>
<#        if (state.ExitActions.Any()) {#>
        public virtual async Task <#= state.Name.ToValidCSharpName() #>ExitedAsync(NSFStateMachineContext oContext, NSFState state)
        {
            try {
<#            foreach (var sAction in state.ExitActions.Where(a => string.IsNullOrEmpty(a) == false)) { #>
                await MainModel.<#= sAction#>().ConfigureAwait(continueOnCapturedContext:false);;
<#            }#>
                this.RaiseStateExitEvent(oContext, state);
            }
            catch (Exception e)
            {
                ms_iLogger.LogException(ELogLevel.Error, e.Source, e);
                this.SendStateEvent(UndefinedFaultEvent);
            }
        }
<#        }#>
<#  } #>

        #endregion States Actions

	    #region Transitions Actions
<#  var previousActionNames = new HashSet<string>();
    foreach (var group in model.NSF.GetGroupedTransitions())  {  
        foreach (var trans in group.GroupBy(g => g.Name).Select(g => g.First()).Where(t => string.IsNullOrEmpty(t.ActionName) == false)) { 
            if (previousActionNames.Add(trans.ActionName) == false) continue; //avoid duplicates
            var eTrans= trans as ExternalTransition;
            var iTrans= trans as InternalTransition;
            string triggerName = "'trigger is missing'"; 
            if (trans.Trigger != null) triggerName = trans.Trigger.Name; 
#>
        /// <summary>
<#          if (eTrans != null) Ext.WriteTokensAtTabs(this, 2,"/// This method is called when the '" +  eTrans.SourceState.Name + "' transitions to '" + eTrans.Target.Name + "'");
            else Ext.WriteTokensAtTabs(this, 2,"/// This method is called when transitioning from '" +  iTrans.SourceState.Name + "'"); #>
        /// triggered by '<#= triggerName #>' 
        /// </summary>
        /// <param name="oContext">Information about the states before and after the transition as well as the transition and trigger.</param>
        /// <returns>Nothing</returns>
        public virtual async Task <#= trans.ActionName #>(NSFStateMachineContext oContext)
        {
<#          if (trans.Actions != null) { #>
            try {
<#                var previousActions = new HashSet<string>();
                foreach (var tAct in trans.Actions) { 
                    if (previousActions.Add(tAct) == false) continue;
                    if (StringExtensions.IsValidIdentifier(tAct) == false) { 
                        Ext.WriteTokensAtTabs(this,4, "// +++ Invalid Action name '" + tAct.ToString() + "' in " + triggerName);
                        continue; 
                    }
                    Ext.WriteTokensAtTabs(this, 4,"await MainModel." +  tAct + "(oContext).ConfigureAwait(continueOnCapturedContext:false);");
            }
#>
            }
            catch (Exception e) {
                ms_iLogger.LogException(ELogLevel.Error, e.Source, e);
                this.SendStateEvent(UndefinedFaultEvent);
            }
<#            } else {#>
            await Task.CompletedTask;
<#            } #>
        }

<#        } 
    } #>
		#endregion Transitions Actions

	    #region Transitions Choices and Guards
<#  var previousGuards = new HashSet<string>();
    foreach (var group in model.NSF.GetGroupedTransitions())  {  
        foreach (var trans in group.GroupBy(g => g.Name).Select(g => g.First()).Where(t => string.IsNullOrEmpty(t.GuardName) == false)) { 
            if (previousGuards.Add(trans.GuardName) == false) continue; //avoid duplicates 
            if (trans.GuardName.ToUpper() == "NONE") continue; //skip Guards named "None"
            if (trans.GuardName.ToUpper() == "ELSE") continue; //skip Guards named "Else"
            var simulationIndicatorName = trans.GuardName + "_InSimulationMode";
            var simulationValueName= trans.GuardName + "_SimulatedValue";
#>
        #region <#= trans.GuardName #>

        public bool <#= simulationIndicatorName #> { get; set; }
        public bool <#= simulationValueName #> { get; set; }

        /// <summary>
        /// A Guard function returning the State of '<#= trans.GuardName #>'.
        /// Defined at Transition <#= trans.Name #>
        /// </summary>
        /// <param name="oContext">Information about the states before and after the transition as well as the transition and trigger.</param>
        /// <returns>guard result</returns>
        public virtual bool <#= trans.GuardName #>(NSFStateMachineContext oContext)
        {
            if (<#= simulationIndicatorName #> == true) 
                return <#= simulationValueName #>;
            else 
                return MainModel.<#= trans.GuardName #>;
        }
        #endregion <#= trans.GuardName #>

<#        } 
    } #>
		#endregion Transitions Choices and Guards

	    #region Other methods

        public bool StartStateMachine()
        {
            // Support StateMachine specific log
        
            NSFTraceLog.PrimaryTraceLog.Enabled = true;
            StateChangeActions += HandleStateChange;
        
            // Start State machine
            startStateMachine();
        
            return true;
        }

        public bool StopStateMachine()
        {
            stopStateMachine();
            // Save trace log
            NSFTraceLog.PrimaryTraceLog.saveLog("<#= model.ProjectName #>StateMachineLog.xml");
            NSFEnvironment.terminate();
        
            return true;
        }

<#@ include file="Parts/InvokeEvent.t4" #>

        #region Indicators Dictionary
        private Dictionary<string, PropertyInfo> indicatorsDictionary;
        public Dictionary<string, PropertyInfo> IndicatorsDictionary
        {
            get
            {
                if (indicatorsDictionary == null)
                {
                    indicatorsDictionary = new Dictionary<string, PropertyInfo>();
                    var indicatorProperties = MainModel.GetType().GetProperties(BindingFlags.Instance | BindingFlags.Public)
                        .Where(p => p.Name.StartsWith("IsIn") && p.PropertyType == typeof(bool));
                    indicatorProperties.ToList().ForEach(p => indicatorsDictionary.Add(p.Name, p));
                }
                return indicatorsDictionary;
            }
        }
        #endregion Indicators Dictionary

        /// <summary>
        /// This method is called when a State is Entered.
        /// Must be synchronous, non-blocking, no-locks, return on when-all-completed only and run all subscribers concurrently
        /// </summary>
        /// <param name="oContext">Information about the states before and after the transition as well as the transition and trigger.</param> 
        /// <param name="state">State that is changing.</param> 
        /// <returns>Nothing</returns>
        protected void RaiseStateEnterEvent(NSFStateMachineContext oContext, NSFState state)
        {
            //TODO: queue new state
            var propName = "IsIn" + state.Name.Substring(1);
            if (state.GetType() == typeof(NSFCompositeState) && IndicatorsDictionary.ContainsKey(propName))
                IndicatorsDictionary[propName].SetValue(MainModel, true);

            //if (StateEnteredAsync != null)
            //{
            //    var asyncHandlers = StateEnteredAsync.GetInvocationList().Cast<StateChangingEventHandler>();
            //    var asyncHandlerTasks = new List<Task>();
            //    asyncHandlers.ToList().ForEach(delgt => asyncHandlerTasks.Add(new Task(() => delgt(new PropertyChangedEventArgs(state.Name)))));
            //    await Task.WhenAll(asyncHandlerTasks.ToArray());
            //}
        }

        /// <summary>
        /// This method is called when a State is exiting.
        /// Must be synchronous, non-blocking, no-locks, return on when-all-completed only and run all subscribers concurrently
        /// </summary>
        /// <param name="oContext">Information about the states before and after the transition as well as the transition and trigger.</param> 
        /// <param name="state">State that is changing.</param> 
        /// <returns>Nothing</returns>
        protected void RaiseStateExitEvent(NSFStateMachineContext oContext, NSFState state)
        {
            //TODO: queue new state
            var propName = "IsIn" + state.Name.Substring(1);
            if (state.GetType() == typeof(NSFCompositeState) && IndicatorsDictionary.ContainsKey(propName))
                IndicatorsDictionary[propName].SetValue(MainModel, false);

            //if (StateExitedAsync != null)
            //{
            //    var asyncHandlers = StateExitedAsync.GetInvocationList().Cast<StateChangedEventHandler>();
            //    var asyncHandlerTasks = new List<Task>();
            //    asyncHandlers.ToList().ForEach(delgt =>
            //        asyncHandlerTasks.Add(new Task(() => delgt(new PropertyChangedEventArgs(state.Name)))));
            //    await Task.WhenAll(asyncHandlerTasks.ToArray());
            //}
        }

        /// <summary>}
        /// Called by the NSF whenever there is a state change}
        /// </summary>}
        /// <param name="oContext"></param>}
        private void HandleStateChange(NSFStateMachineContext oContext)
        {
            PreviousState = CurrentState;
            CurrentState = GetState(oContext.EnteringState.Name);
            //PreviousStateName = CurrentStateName;
            //if (CurrentStateName == null) CurrentStateName = "none";
            //else CurrentStateName = ((EState)CurrentState).ToString();
            PreviousContext = CurrentContext;
            CurrentContext = oContext;

            if (oContext.EnteringState is NSFChoiceState) //(strNewState.StartsWith("Is"))
            {
                string strMsg = $@"Evaluating {CurrentState} state after {PreviousState} state.";
                ms_iLogger.XLog(ELogLevel.Info, strMsg, new SCodeContext(CurrentState));
                return;
            }
            else
            {
                string strMsg;
                if (PreviousState == null)
                    strMsg = $"Starting at the {CurrentState} state!";
                else
                    strMsg = $"Leaving {PreviousState} state to {CurrentState} state!";

                ms_iLogger.XLog(ELogLevel.Info, strMsg, new SCodeContext(CurrentState));
                SystemState = oContext.EnteringState.Name;
            }

            // Is there an operator prompt to display for this new state?
            (string OperatorPrompt, bool HighlightOperator) oPromptDetails = ("", false);
            if (CurrentState != null)
                OperatorPromptForStateDict.TryGetValue(((EState) CurrentState), out oPromptDetails);
            
            StateChangesEventArgs.OperatorPrompt = LastOperatorPrompt = oPromptDetails.OperatorPrompt;
            StateChangesEventArgs.HandledStateName = CurrentState.ToString();
            StateChangesEventArgs.HighlightPrompt = oPromptDetails.HighlightOperator;

            // Notify anyone subscribed to the State Changed event
            try
            {
                StateChangesEvent?.Invoke(this, StateChangesEventArgs);
            }
            catch (Exception e)
            {
                ms_iLogger.LogException(ELogLevel.Fatal, e.Message, e);
            }

            try
            {
                StateChangesAtStateEvent?.Invoke(this, StateChangesEventArgs);
            }
            catch (Exception e)
            {
                ms_iLogger.LogException(ELogLevel.Fatal, e.Message, e);
            }
        }

        public bool SendStateEvent(NSFEventName eventName, object oEventData = null, [CallerLineNumber] int lineNumber = 0, [CallerMemberName] string caller = null)
        {
            if (!Triggers.ContainsKey(eventName))
            {
                ms_iLogger.XLog(ELogLevel.Error, "Invalid Event passed to SendStateEvent!", new SCodeContext(CurrentState));
                return false;
            }

            try
            {

                // Get event from enum passed in
                NSFEvent oEvent = Triggers[eventName];

                // Handle event data
                if (oEventData == null)
                {
                    // queue the event to the StateMachine
                    queueEvent(oEvent);
                }
                else
                {
                    // Queue the event and EventData to the state machine
                    CStateMachineEventData oStateMachineEventData = new CStateMachineEventData(oEventData);
                    queueEvent(oEvent, oStateMachineEventData);
                }

                // Log Event
                string strMsg = $@" Received Event ""{eventName}"" from {caller} @ {lineNumber}";
                ms_iLogger.XLog(ELogLevel.Info, strMsg, new SCodeContext(CurrentState));

                return true;
            }
            catch (Exception ex)
            {
                string strMsg = String.Format(@"Error!  Unable to handle handle event <#= Session["typeName"].ToString() #>!", eventName);
                ms_iLogger.LogException(ELogLevel.Error, strMsg, ex);
            }

            return false;
        }


        public string GetState(EState eState) { 
            var name = "o" + eState + "State"; 
            if (GetState(name) == null) name = "o" + eState;
            else if (GetState(name) == null) name = eState.ToString();
            return name;
        }

        public EState? GetState(string strState)
        {
            var strippedName = strState.Substring(1); //remove prefix "o"
            if (strippedName.EndsWith("State"))
                strippedName = strippedName.Substring(0, strippedName.Length - "State".Length); //Remove suffix State
            EState eStateNew;
            var nullableState = Enum.TryParse(strippedName, out eStateNew) ? (EState?)eStateNew : null;

            return nullableState;
        }

	    #endregion Other methods

        #endregion State Machine Methods
	}

    #region Enums
        #region Trigger's enum
        public partial class TriggerName
        {
<# foreach (var triggerName in model.NSF.GetTriggerNames())  { #>
		    public const NSFEventName <#= triggerName.ToValidCSharpName() #> = nameof(<#= triggerName.ToValidCSharpName() #>);
<# } #>
        }
        #endregion Trigger's enum
 
    public enum EState
    {
		    none,
<# foreach (var state in model.States.OrderBy(s => s.Name))  { #>
		    <#= state.Name.ToValidCSharpName().Replace("State","") #>,
<# } #>
    }
    #endregion Enums
}
